---
// src/pages/[slug].astro - Moved from src/pages/transcripts/
import MainLayout from '../../layouts/MainLayout.astro';

// Required for dynamic routes
export async function getStaticPaths() {
  try {
    // Use import.meta.glob for more reliable file loading
    const transcriptModulesMeta = import.meta.glob('../../content/transcripts/*.html', { query: 'raw', eager: true });
    
    // Create paths for all HTML files in the transcripts directory
    const contentPaths = Object.entries(transcriptModulesMeta).map(([filePath, rawHtmlContent]) => {
      // Extract slug from filename (e.g., '../content/transcripts/ep01.html' -> 'ep01')
      const slug = filePath.split('/').pop().replace('.html', '');
      return {
        params: { slug },
        props: { rawHtmlContent } // Pass the raw HTML content
      };
    });
    
    // Add specific handling for numeric routes that might not have content files
    // This prevents the "Missing parameter: slug" error for routes like /pages/0/
    const numericPaths = [];
    for (let i = 0; i <= 25; i++) { // Support up to episode 25
      const numericSlug = String(i);
      // Only add if it doesn't already exist in contentPaths
      if (!contentPaths.some(path => path.params.slug === numericSlug)) {
        numericPaths.push({
          params: { slug: numericSlug },
          props: { rawHtmlContent: {} } // Empty content to be handled in the component
        });
      }
    }
    
    // Combine all paths
    const allPaths = [...contentPaths, ...numericPaths];
    console.log(`[getStaticPaths] Generated ${allPaths.length} paths`);
    return allPaths;
  } catch (error) {
    console.error('[getStaticPaths] Error generating paths:', error);
    return []; 
  }
}

// Get the raw HTML content passed via props
const { slug } = Astro.params;
const { rawHtmlContent } = Astro.props;

let title = slug; // Default title
let bodyContent = ''; // Variable for extracted body content

// Handle different rawHtmlContent formats more robustly
let htmlString = '';

if (typeof rawHtmlContent === 'string') {
  htmlString = rawHtmlContent;
} else if (rawHtmlContent && typeof rawHtmlContent === 'object') {
  // Handle both import.meta.glob format (rawHtmlContent.default) and Astro.glob format
  htmlString = rawHtmlContent.default || '';
}

try {
  // Handle empty content cases first (numeric slugs or missing content)
  if (!htmlString || htmlString.trim() === '') {
    // Handle numeric episode slugs (0-25)
    if (/^\d+$/.test(slug)) {
      const episodeNum = parseInt(slug, 10);
      title = `Episode ${episodeNum}`;
      bodyContent = `
        <div class="episode-content">
          <div class="video-container placeholder-container">
            <div class="placeholder-media">
              <div class="placeholder-icon">üìπ</div>
              <p>Video content for Episode ${episodeNum} is being prepared</p>
            </div>
          </div>
          <div class="transcript-section">
            <h2>Transcript</h2>
            <p>The transcript for Episode ${episodeNum} is being prepared. Please check back later.</p>
            <p><a href="/" class="home-link">Browse other episodes</a></p>
          </div>
        </div>
      `;
      console.log(`Using enhanced placeholder for numeric slug: ${slug}`);
    } else {
      // Handle non-numeric missing content
      const formattedTitle = slug?.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Content';
      title = formattedTitle;
      bodyContent = `
        <div class="content-placeholder">
          <h2>${formattedTitle}</h2>
          <p>Content is currently being prepared. Please check back later.</p>
          <p><a href="/" class="home-link">Return to home page</a></p>
        </div>
      `;
      console.log(`Using enhanced placeholder for slug: ${slug}`);
    }
  }
  
  // Only proceed with string operations if htmlString is a valid string
  if (typeof htmlString === 'string') {
    // Attempt to extract title from <title> tag if present in the HTML
    const titleMatch = htmlString.match(/<title>(.*?)<\/title>/i);
    if (titleMatch && titleMatch[1]) {
      title = titleMatch[1].trim();
    }

    // Attempt to extract content between <body> tags
    const bodyMatch = htmlString.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
    if (bodyMatch && bodyMatch[1]) {
      bodyContent = bodyMatch[1].trim();
      // Basic fix for relative paths within the injected HTML:
      // Replace ../ with / for root-relative paths assuming assets are in public/
      // Adjusted this relative path fix logic as well, assuming assets are in /public
      // This might need refinement depending on actual asset structure in HTML files
      bodyContent = bodyContent.replace(/\.\.\//g, '/'); 
    } else {
      // If body is missing, the raw content might be the body itself
      bodyContent = htmlString;
      title = `${slug?.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) ?? 'Transcript'}`;
    }
  }
} catch (error) {
  console.error(`Error processing transcript content for slug ${slug}:`, error);
  // Create a more user-friendly error message and properly formatted content
  title = `${slug?.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) ?? 'Content'}`;
  bodyContent = `
    <div class="error-container">
      <h2>Content is being prepared</h2>
      <p>The content for ${title} is currently being updated. Please check back later.</p>
      <a href="/" class="home-link">Return to Home</a>
    </div>
  `;
}

---

<MainLayout title={`${title} - Transcript`}>
  <main class="container">
    <a href="/" class="back-link" onclick="event.preventDefault(); window.history.back();" data-testid="back-link">‚Üê Back</a>

    <div class="episode-content">
      <h1>{title}</h1>

      <div class="transcript-body-content">
        <div set:html={bodyContent} />
      </div>
    </div>
  </main>
</MainLayout>

<style is:global>
  .container {
    max-width: 1140px;
    margin: 0 auto;
    padding: 0 15px;
  }
  .back-link {
    display: inline-block;
    margin: 1rem 0;
    color: #007bff;
    text-decoration: none;
  }
  .back-link:hover {
    text-decoration: underline;
  }
  .episode-content {
    margin-bottom: 2rem;
  }
  .video-container {
    position: relative;
    margin-bottom: 1.5rem;
  }
  .video-container img {
    max-width: 100%;
    height: auto;
    display: block;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }
  .episode-content h1 {
    margin-bottom: 1em;
  }
  .transcript-body-content p {
    margin-bottom: 1em;
    line-height: 1.6;
  }
  .transcript-body-content a {
    color: #007bff;
    text-decoration: none;
  }
  .transcript-body-content a:hover {
    text-decoration: underline;
  }
  
  /* Error container styling */
  .error-container {
    text-align: center;
    padding: 2rem;
    margin: 2rem auto;
    max-width: 600px;
    background-color: #f8f9fa;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  }
  
  .error-container h2 {
    color: #0066cc;
    margin-bottom: 1rem;
  }
  
  .error-container p {
    margin-bottom: 1.5rem;
    color: #555;
  }
  
  .home-link {
    display: inline-block;
    padding: 0.5rem 1.5rem;
    background-color: #0066cc;
    color: white;
    text-decoration: none;
    border-radius: 4px;
    font-weight: 500;
    transition: background-color 0.2s;
  }
  
  .home-link:hover {
    background-color: #0055aa;
    text-decoration: none;
  }
  
  /* Placeholder styling */
  .placeholder-container {
    background-color: #f8f9fa;
    border-radius: 8px;
    padding: 2rem;
    text-align: center;
    margin-bottom: 2rem;
  }
  
  .placeholder-media {
    padding: 3rem 1rem;
  }
  
  .placeholder-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
  }
  
  .content-placeholder {
    background-color: #f8f9fa;
    border-radius: 8px;
    padding: 3rem 2rem;
    text-align: center;
    margin: 2rem auto;
    max-width: 600px;
  }
</style>
