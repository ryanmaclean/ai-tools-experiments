"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecurityMonitoringApi = exports.SecurityMonitoringApiResponseProcessor = exports.SecurityMonitoringApiRequestFactory = void 0;
const baseapi_1 = require("../../datadog-api-client-common/baseapi");
const configuration_1 = require("../../datadog-api-client-common/configuration");
const http_1 = require("../../datadog-api-client-common/http/http");
const logger_1 = require("../../../logger");
const ObjectSerializer_1 = require("../models/ObjectSerializer");
const exception_1 = require("../../datadog-api-client-common/exception");
const SecurityMonitoringSignalListRequest_1 = require("../models/SecurityMonitoringSignalListRequest");
const SecurityMonitoringSignalListRequestPage_1 = require("../models/SecurityMonitoringSignalListRequestPage");
class SecurityMonitoringApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    cancelHistoricalJob(jobId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'cancelHistoricalJob'");
            if (!_config.unstableOperations["v2.cancelHistoricalJob"]) {
                throw new Error("Unstable operation 'cancelHistoricalJob' is disabled");
            }
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new baseapi_1.RequiredError("jobId", "cancelHistoricalJob");
            }
            // Path Params
            const localVarPath = "/api/v2/siem-historical-detections/jobs/{job_id}/cancel".replace("{job_id}", encodeURIComponent(String(jobId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.cancelHistoricalJob")
                .makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    convertExistingSecurityMonitoringRule(ruleId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new baseapi_1.RequiredError("ruleId", "convertExistingSecurityMonitoringRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules/{rule_id}/convert".replace("{rule_id}", encodeURIComponent(String(ruleId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.convertExistingSecurityMonitoringRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    convertJobResultToSignal(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'convertJobResultToSignal'");
            if (!_config.unstableOperations["v2.convertJobResultToSignal"]) {
                throw new Error("Unstable operation 'convertJobResultToSignal' is disabled");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "convertJobResultToSignal");
            }
            // Path Params
            const localVarPath = "/api/v2/siem-historical-detections/jobs/signal_convert";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.convertJobResultToSignal")
                .makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ConvertJobResultsToSignalsRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    convertSecurityMonitoringRuleFromJSONToTerraform(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "convertSecurityMonitoringRuleFromJSONToTerraform");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules/convert";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.convertSecurityMonitoringRuleFromJSONToTerraform")
                .makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringRuleConvertPayload", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createSecurityFilter(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createSecurityFilter");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/security_filters";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.createSecurityFilter")
                .makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityFilterCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createSecurityMonitoringRule(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createSecurityMonitoringRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.createSecurityMonitoringRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringRuleCreatePayload", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createSecurityMonitoringSuppression(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createSecurityMonitoringSuppression");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/suppressions";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.createSecurityMonitoringSuppression")
                .makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringSuppressionCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createSignalNotificationRule(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createSignalNotificationRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security/signals/notification_rules";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.createSignalNotificationRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "CreateNotificationRuleParameters", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createVulnerabilityNotificationRule(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createVulnerabilityNotificationRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security/vulnerabilities/notification_rules";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.createVulnerabilityNotificationRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "CreateNotificationRuleParameters", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteHistoricalJob(jobId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'deleteHistoricalJob'");
            if (!_config.unstableOperations["v2.deleteHistoricalJob"]) {
                throw new Error("Unstable operation 'deleteHistoricalJob' is disabled");
            }
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new baseapi_1.RequiredError("jobId", "deleteHistoricalJob");
            }
            // Path Params
            const localVarPath = "/api/v2/siem-historical-detections/jobs/{job_id}".replace("{job_id}", encodeURIComponent(String(jobId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.deleteHistoricalJob")
                .makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteSecurityFilter(securityFilterId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'securityFilterId' is not null or undefined
            if (securityFilterId === null || securityFilterId === undefined) {
                throw new baseapi_1.RequiredError("securityFilterId", "deleteSecurityFilter");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/security_filters/{security_filter_id}".replace("{security_filter_id}", encodeURIComponent(String(securityFilterId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.deleteSecurityFilter")
                .makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteSecurityMonitoringRule(ruleId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new baseapi_1.RequiredError("ruleId", "deleteSecurityMonitoringRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules/{rule_id}".replace("{rule_id}", encodeURIComponent(String(ruleId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.deleteSecurityMonitoringRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteSecurityMonitoringSuppression(suppressionId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'suppressionId' is not null or undefined
            if (suppressionId === null || suppressionId === undefined) {
                throw new baseapi_1.RequiredError("suppressionId", "deleteSecurityMonitoringSuppression");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/suppressions/{suppression_id}".replace("{suppression_id}", encodeURIComponent(String(suppressionId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.deleteSecurityMonitoringSuppression")
                .makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteSignalNotificationRule(id, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new baseapi_1.RequiredError("id", "deleteSignalNotificationRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security/signals/notification_rules/{id}".replace("{id}", encodeURIComponent(String(id)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.deleteSignalNotificationRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteVulnerabilityNotificationRule(id, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new baseapi_1.RequiredError("id", "deleteVulnerabilityNotificationRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security/vulnerabilities/notification_rules/{id}".replace("{id}", encodeURIComponent(String(id)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.deleteVulnerabilityNotificationRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    editSecurityMonitoringSignalAssignee(signalId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'signalId' is not null or undefined
            if (signalId === null || signalId === undefined) {
                throw new baseapi_1.RequiredError("signalId", "editSecurityMonitoringSignalAssignee");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "editSecurityMonitoringSignalAssignee");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/signals/{signal_id}/assignee".replace("{signal_id}", encodeURIComponent(String(signalId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.editSecurityMonitoringSignalAssignee")
                .makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringSignalAssigneeUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    editSecurityMonitoringSignalIncidents(signalId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'signalId' is not null or undefined
            if (signalId === null || signalId === undefined) {
                throw new baseapi_1.RequiredError("signalId", "editSecurityMonitoringSignalIncidents");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "editSecurityMonitoringSignalIncidents");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/signals/{signal_id}/incidents".replace("{signal_id}", encodeURIComponent(String(signalId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.editSecurityMonitoringSignalIncidents")
                .makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringSignalIncidentsUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    editSecurityMonitoringSignalState(signalId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'signalId' is not null or undefined
            if (signalId === null || signalId === undefined) {
                throw new baseapi_1.RequiredError("signalId", "editSecurityMonitoringSignalState");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "editSecurityMonitoringSignalState");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/signals/{signal_id}/state".replace("{signal_id}", encodeURIComponent(String(signalId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.editSecurityMonitoringSignalState")
                .makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringSignalStateUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getFinding(findingId, snapshotTimestamp, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'getFinding'");
            if (!_config.unstableOperations["v2.getFinding"]) {
                throw new Error("Unstable operation 'getFinding' is disabled");
            }
            // verify required parameter 'findingId' is not null or undefined
            if (findingId === null || findingId === undefined) {
                throw new baseapi_1.RequiredError("findingId", "getFinding");
            }
            // Path Params
            const localVarPath = "/api/v2/posture_management/findings/{finding_id}".replace("{finding_id}", encodeURIComponent(String(findingId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.getFinding")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (snapshotTimestamp !== undefined) {
                requestContext.setQueryParam("snapshot_timestamp", ObjectSerializer_1.ObjectSerializer.serialize(snapshotTimestamp, "number", "int64"), "");
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getHistoricalJob(jobId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'getHistoricalJob'");
            if (!_config.unstableOperations["v2.getHistoricalJob"]) {
                throw new Error("Unstable operation 'getHistoricalJob' is disabled");
            }
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new baseapi_1.RequiredError("jobId", "getHistoricalJob");
            }
            // Path Params
            const localVarPath = "/api/v2/siem-historical-detections/jobs/{job_id}".replace("{job_id}", encodeURIComponent(String(jobId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.getHistoricalJob")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getRuleVersionHistory(ruleId, pageSize, pageNumber, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'getRuleVersionHistory'");
            if (!_config.unstableOperations["v2.getRuleVersionHistory"]) {
                throw new Error("Unstable operation 'getRuleVersionHistory' is disabled");
            }
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new baseapi_1.RequiredError("ruleId", "getRuleVersionHistory");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules/{rule_id}/version_history".replace("{rule_id}", encodeURIComponent(String(ruleId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.getRuleVersionHistory")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"), "");
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"), "");
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSBOM(assetType, filterAssetName, filterRepoDigest, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'getSBOM'");
            if (!_config.unstableOperations["v2.getSBOM"]) {
                throw new Error("Unstable operation 'getSBOM' is disabled");
            }
            // verify required parameter 'assetType' is not null or undefined
            if (assetType === null || assetType === undefined) {
                throw new baseapi_1.RequiredError("assetType", "getSBOM");
            }
            // verify required parameter 'filterAssetName' is not null or undefined
            if (filterAssetName === null || filterAssetName === undefined) {
                throw new baseapi_1.RequiredError("filterAssetName", "getSBOM");
            }
            // Path Params
            const localVarPath = "/api/v2/security/sboms/{asset_type}".replace("{asset_type}", encodeURIComponent(String(assetType)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.getSBOM")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filterAssetName !== undefined) {
                requestContext.setQueryParam("filter[asset_name]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetName, "string", ""), "");
            }
            if (filterRepoDigest !== undefined) {
                requestContext.setQueryParam("filter[repo_digest]", ObjectSerializer_1.ObjectSerializer.serialize(filterRepoDigest, "string", ""), "");
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSecurityFilter(securityFilterId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'securityFilterId' is not null or undefined
            if (securityFilterId === null || securityFilterId === undefined) {
                throw new baseapi_1.RequiredError("securityFilterId", "getSecurityFilter");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/security_filters/{security_filter_id}".replace("{security_filter_id}", encodeURIComponent(String(securityFilterId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.getSecurityFilter")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSecurityMonitoringRule(ruleId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new baseapi_1.RequiredError("ruleId", "getSecurityMonitoringRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules/{rule_id}".replace("{rule_id}", encodeURIComponent(String(ruleId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.getSecurityMonitoringRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSecurityMonitoringSignal(signalId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'signalId' is not null or undefined
            if (signalId === null || signalId === undefined) {
                throw new baseapi_1.RequiredError("signalId", "getSecurityMonitoringSignal");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/signals/{signal_id}".replace("{signal_id}", encodeURIComponent(String(signalId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.getSecurityMonitoringSignal")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSecurityMonitoringSuppression(suppressionId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'suppressionId' is not null or undefined
            if (suppressionId === null || suppressionId === undefined) {
                throw new baseapi_1.RequiredError("suppressionId", "getSecurityMonitoringSuppression");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/suppressions/{suppression_id}".replace("{suppression_id}", encodeURIComponent(String(suppressionId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.getSecurityMonitoringSuppression")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSignalNotificationRule(id, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new baseapi_1.RequiredError("id", "getSignalNotificationRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security/signals/notification_rules/{id}".replace("{id}", encodeURIComponent(String(id)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.getSignalNotificationRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSignalNotificationRules(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/security/signals/notification_rules";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.getSignalNotificationRules")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getVulnerabilityNotificationRule(id, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new baseapi_1.RequiredError("id", "getVulnerabilityNotificationRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security/vulnerabilities/notification_rules/{id}".replace("{id}", encodeURIComponent(String(id)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.getVulnerabilityNotificationRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getVulnerabilityNotificationRules(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/security/vulnerabilities/notification_rules";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.getVulnerabilityNotificationRules")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listFindings(pageLimit, snapshotTimestamp, pageCursor, filterTags, filterEvaluationChangedAt, filterMuted, filterRuleId, filterRuleName, filterResourceType, filterDiscoveryTimestamp, filterEvaluation, filterStatus, filterVulnerabilityType, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'listFindings'");
            if (!_config.unstableOperations["v2.listFindings"]) {
                throw new Error("Unstable operation 'listFindings' is disabled");
            }
            // Path Params
            const localVarPath = "/api/v2/posture_management/findings";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.listFindings")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageLimit !== undefined) {
                requestContext.setQueryParam("page[limit]", ObjectSerializer_1.ObjectSerializer.serialize(pageLimit, "number", "int64"), "");
            }
            if (snapshotTimestamp !== undefined) {
                requestContext.setQueryParam("snapshot_timestamp", ObjectSerializer_1.ObjectSerializer.serialize(snapshotTimestamp, "number", "int64"), "");
            }
            if (pageCursor !== undefined) {
                requestContext.setQueryParam("page[cursor]", ObjectSerializer_1.ObjectSerializer.serialize(pageCursor, "string", ""), "");
            }
            if (filterTags !== undefined) {
                requestContext.setQueryParam("filter[tags]", ObjectSerializer_1.ObjectSerializer.serialize(filterTags, "string", ""), "");
            }
            if (filterEvaluationChangedAt !== undefined) {
                requestContext.setQueryParam("filter[evaluation_changed_at]", ObjectSerializer_1.ObjectSerializer.serialize(filterEvaluationChangedAt, "string", ""), "");
            }
            if (filterMuted !== undefined) {
                requestContext.setQueryParam("filter[muted]", ObjectSerializer_1.ObjectSerializer.serialize(filterMuted, "boolean", ""), "");
            }
            if (filterRuleId !== undefined) {
                requestContext.setQueryParam("filter[rule_id]", ObjectSerializer_1.ObjectSerializer.serialize(filterRuleId, "string", ""), "");
            }
            if (filterRuleName !== undefined) {
                requestContext.setQueryParam("filter[rule_name]", ObjectSerializer_1.ObjectSerializer.serialize(filterRuleName, "string", ""), "");
            }
            if (filterResourceType !== undefined) {
                requestContext.setQueryParam("filter[resource_type]", ObjectSerializer_1.ObjectSerializer.serialize(filterResourceType, "string", ""), "");
            }
            if (filterDiscoveryTimestamp !== undefined) {
                requestContext.setQueryParam("filter[discovery_timestamp]", ObjectSerializer_1.ObjectSerializer.serialize(filterDiscoveryTimestamp, "string", ""), "");
            }
            if (filterEvaluation !== undefined) {
                requestContext.setQueryParam("filter[evaluation]", ObjectSerializer_1.ObjectSerializer.serialize(filterEvaluation, "FindingEvaluation", ""), "");
            }
            if (filterStatus !== undefined) {
                requestContext.setQueryParam("filter[status]", ObjectSerializer_1.ObjectSerializer.serialize(filterStatus, "FindingStatus", ""), "");
            }
            if (filterVulnerabilityType !== undefined) {
                requestContext.setQueryParam("filter[vulnerability_type]", ObjectSerializer_1.ObjectSerializer.serialize(filterVulnerabilityType, "Array<FindingVulnerabilityType>", ""), "multi");
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listHistoricalJobs(pageSize, pageNumber, sort, filterQuery, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'listHistoricalJobs'");
            if (!_config.unstableOperations["v2.listHistoricalJobs"]) {
                throw new Error("Unstable operation 'listHistoricalJobs' is disabled");
            }
            // Path Params
            const localVarPath = "/api/v2/siem-historical-detections/jobs";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.listHistoricalJobs")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"), "");
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"), "");
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "string", ""), "");
            }
            if (filterQuery !== undefined) {
                requestContext.setQueryParam("filter[query]", ObjectSerializer_1.ObjectSerializer.serialize(filterQuery, "string", ""), "");
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listSecurityFilters(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/security_filters";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.listSecurityFilters")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listSecurityMonitoringRules(pageSize, pageNumber, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.listSecurityMonitoringRules")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"), "");
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"), "");
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listSecurityMonitoringSignals(filterQuery, filterFrom, filterTo, sort, pageCursor, pageLimit, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/signals";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.listSecurityMonitoringSignals")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filterQuery !== undefined) {
                requestContext.setQueryParam("filter[query]", ObjectSerializer_1.ObjectSerializer.serialize(filterQuery, "string", ""), "");
            }
            if (filterFrom !== undefined) {
                requestContext.setQueryParam("filter[from]", ObjectSerializer_1.ObjectSerializer.serialize(filterFrom, "Date", "date-time"), "");
            }
            if (filterTo !== undefined) {
                requestContext.setQueryParam("filter[to]", ObjectSerializer_1.ObjectSerializer.serialize(filterTo, "Date", "date-time"), "");
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "SecurityMonitoringSignalsSort", ""), "");
            }
            if (pageCursor !== undefined) {
                requestContext.setQueryParam("page[cursor]", ObjectSerializer_1.ObjectSerializer.serialize(pageCursor, "string", ""), "");
            }
            if (pageLimit !== undefined) {
                requestContext.setQueryParam("page[limit]", ObjectSerializer_1.ObjectSerializer.serialize(pageLimit, "number", "int32"), "");
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listSecurityMonitoringSuppressions(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/suppressions";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.listSecurityMonitoringSuppressions")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listVulnerabilities(pageToken, pageNumber, filterType, filterCvssBaseScoreOp, filterCvssBaseSeverity, filterCvssBaseVector, filterCvssDatadogScoreOp, filterCvssDatadogSeverity, filterCvssDatadogVector, filterStatus, filterTool, filterLibraryName, filterLibraryVersion, filterAdvisoryId, filterRisksExploitationProbability, filterRisksPocExploitAvailable, filterRisksExploitAvailable, filterRisksEpssScoreOp, filterRisksEpssSeverity, filterLanguage, filterEcosystem, filterCodeLocationLocation, filterCodeLocationFilePath, filterCodeLocationMethod, filterFixAvailable, filterRepoDigests, filterAssetName, filterAssetType, filterAssetVersionFirst, filterAssetVersionLast, filterAssetRepositoryUrl, filterAssetRisksInProduction, filterAssetRisksUnderAttack, filterAssetRisksIsPubliclyAccessible, filterAssetRisksHasPrivilegedAccess, filterAssetRisksHasAccessToSensitiveData, filterAssetEnvironments, filterAssetArch, filterAssetOperatingSystemName, filterAssetOperatingSystemVersion, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'listVulnerabilities'");
            if (!_config.unstableOperations["v2.listVulnerabilities"]) {
                throw new Error("Unstable operation 'listVulnerabilities' is disabled");
            }
            // Path Params
            const localVarPath = "/api/v2/security/vulnerabilities";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.listVulnerabilities")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageToken !== undefined) {
                requestContext.setQueryParam("page[token]", ObjectSerializer_1.ObjectSerializer.serialize(pageToken, "string", ""), "");
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"), "");
            }
            if (filterType !== undefined) {
                requestContext.setQueryParam("filter[type]", ObjectSerializer_1.ObjectSerializer.serialize(filterType, "VulnerabilityType", ""), "");
            }
            if (filterCvssBaseScoreOp !== undefined) {
                requestContext.setQueryParam("filter[cvss.base.score][`$op`]", ObjectSerializer_1.ObjectSerializer.serialize(filterCvssBaseScoreOp, "number", "double"), "");
            }
            if (filterCvssBaseSeverity !== undefined) {
                requestContext.setQueryParam("filter[cvss.base.severity]", ObjectSerializer_1.ObjectSerializer.serialize(filterCvssBaseSeverity, "VulnerabilitySeverity", ""), "");
            }
            if (filterCvssBaseVector !== undefined) {
                requestContext.setQueryParam("filter[cvss.base.vector]", ObjectSerializer_1.ObjectSerializer.serialize(filterCvssBaseVector, "string", ""), "");
            }
            if (filterCvssDatadogScoreOp !== undefined) {
                requestContext.setQueryParam("filter[cvss.datadog.score][`$op`]", ObjectSerializer_1.ObjectSerializer.serialize(filterCvssDatadogScoreOp, "number", "double"), "");
            }
            if (filterCvssDatadogSeverity !== undefined) {
                requestContext.setQueryParam("filter[cvss.datadog.severity]", ObjectSerializer_1.ObjectSerializer.serialize(filterCvssDatadogSeverity, "VulnerabilitySeverity", ""), "");
            }
            if (filterCvssDatadogVector !== undefined) {
                requestContext.setQueryParam("filter[cvss.datadog.vector]", ObjectSerializer_1.ObjectSerializer.serialize(filterCvssDatadogVector, "string", ""), "");
            }
            if (filterStatus !== undefined) {
                requestContext.setQueryParam("filter[status]", ObjectSerializer_1.ObjectSerializer.serialize(filterStatus, "VulnerabilityStatus", ""), "");
            }
            if (filterTool !== undefined) {
                requestContext.setQueryParam("filter[tool]", ObjectSerializer_1.ObjectSerializer.serialize(filterTool, "VulnerabilityTool", ""), "");
            }
            if (filterLibraryName !== undefined) {
                requestContext.setQueryParam("filter[library.name]", ObjectSerializer_1.ObjectSerializer.serialize(filterLibraryName, "string", ""), "");
            }
            if (filterLibraryVersion !== undefined) {
                requestContext.setQueryParam("filter[library.version]", ObjectSerializer_1.ObjectSerializer.serialize(filterLibraryVersion, "string", ""), "");
            }
            if (filterAdvisoryId !== undefined) {
                requestContext.setQueryParam("filter[advisory_id]", ObjectSerializer_1.ObjectSerializer.serialize(filterAdvisoryId, "string", ""), "");
            }
            if (filterRisksExploitationProbability !== undefined) {
                requestContext.setQueryParam("filter[risks.exploitation_probability]", ObjectSerializer_1.ObjectSerializer.serialize(filterRisksExploitationProbability, "boolean", ""), "");
            }
            if (filterRisksPocExploitAvailable !== undefined) {
                requestContext.setQueryParam("filter[risks.poc_exploit_available]", ObjectSerializer_1.ObjectSerializer.serialize(filterRisksPocExploitAvailable, "boolean", ""), "");
            }
            if (filterRisksExploitAvailable !== undefined) {
                requestContext.setQueryParam("filter[risks.exploit_available]", ObjectSerializer_1.ObjectSerializer.serialize(filterRisksExploitAvailable, "boolean", ""), "");
            }
            if (filterRisksEpssScoreOp !== undefined) {
                requestContext.setQueryParam("filter[risks.epss.score][`$op`]", ObjectSerializer_1.ObjectSerializer.serialize(filterRisksEpssScoreOp, "number", "double"), "");
            }
            if (filterRisksEpssSeverity !== undefined) {
                requestContext.setQueryParam("filter[risks.epss.severity]", ObjectSerializer_1.ObjectSerializer.serialize(filterRisksEpssSeverity, "VulnerabilitySeverity", ""), "");
            }
            if (filterLanguage !== undefined) {
                requestContext.setQueryParam("filter[language]", ObjectSerializer_1.ObjectSerializer.serialize(filterLanguage, "string", ""), "");
            }
            if (filterEcosystem !== undefined) {
                requestContext.setQueryParam("filter[ecosystem]", ObjectSerializer_1.ObjectSerializer.serialize(filterEcosystem, "VulnerabilityEcosystem", ""), "");
            }
            if (filterCodeLocationLocation !== undefined) {
                requestContext.setQueryParam("filter[code_location.location]", ObjectSerializer_1.ObjectSerializer.serialize(filterCodeLocationLocation, "string", ""), "");
            }
            if (filterCodeLocationFilePath !== undefined) {
                requestContext.setQueryParam("filter[code_location.file_path]", ObjectSerializer_1.ObjectSerializer.serialize(filterCodeLocationFilePath, "string", ""), "");
            }
            if (filterCodeLocationMethod !== undefined) {
                requestContext.setQueryParam("filter[code_location.method]", ObjectSerializer_1.ObjectSerializer.serialize(filterCodeLocationMethod, "string", ""), "");
            }
            if (filterFixAvailable !== undefined) {
                requestContext.setQueryParam("filter[fix_available]", ObjectSerializer_1.ObjectSerializer.serialize(filterFixAvailable, "boolean", ""), "");
            }
            if (filterRepoDigests !== undefined) {
                requestContext.setQueryParam("filter[repo_digests]", ObjectSerializer_1.ObjectSerializer.serialize(filterRepoDigests, "string", ""), "");
            }
            if (filterAssetName !== undefined) {
                requestContext.setQueryParam("filter[asset.name]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetName, "string", ""), "");
            }
            if (filterAssetType !== undefined) {
                requestContext.setQueryParam("filter[asset.type]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetType, "AssetType", ""), "");
            }
            if (filterAssetVersionFirst !== undefined) {
                requestContext.setQueryParam("filter[asset.version.first]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetVersionFirst, "string", ""), "");
            }
            if (filterAssetVersionLast !== undefined) {
                requestContext.setQueryParam("filter[asset.version.last]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetVersionLast, "string", ""), "");
            }
            if (filterAssetRepositoryUrl !== undefined) {
                requestContext.setQueryParam("filter[asset.repository_url]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetRepositoryUrl, "string", ""), "");
            }
            if (filterAssetRisksInProduction !== undefined) {
                requestContext.setQueryParam("filter[asset.risks.in_production]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetRisksInProduction, "boolean", ""), "");
            }
            if (filterAssetRisksUnderAttack !== undefined) {
                requestContext.setQueryParam("filter[asset.risks.under_attack]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetRisksUnderAttack, "boolean", ""), "");
            }
            if (filterAssetRisksIsPubliclyAccessible !== undefined) {
                requestContext.setQueryParam("filter[asset.risks.is_publicly_accessible]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetRisksIsPubliclyAccessible, "boolean", ""), "");
            }
            if (filterAssetRisksHasPrivilegedAccess !== undefined) {
                requestContext.setQueryParam("filter[asset.risks.has_privileged_access]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetRisksHasPrivilegedAccess, "boolean", ""), "");
            }
            if (filterAssetRisksHasAccessToSensitiveData !== undefined) {
                requestContext.setQueryParam("filter[asset.risks.has_access_to_sensitive_data]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetRisksHasAccessToSensitiveData, "boolean", ""), "");
            }
            if (filterAssetEnvironments !== undefined) {
                requestContext.setQueryParam("filter[asset.environments]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetEnvironments, "string", ""), "");
            }
            if (filterAssetArch !== undefined) {
                requestContext.setQueryParam("filter[asset.arch]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetArch, "string", ""), "");
            }
            if (filterAssetOperatingSystemName !== undefined) {
                requestContext.setQueryParam("filter[asset.operating_system.name]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetOperatingSystemName, "string", ""), "");
            }
            if (filterAssetOperatingSystemVersion !== undefined) {
                requestContext.setQueryParam("filter[asset.operating_system.version]", ObjectSerializer_1.ObjectSerializer.serialize(filterAssetOperatingSystemVersion, "string", ""), "");
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listVulnerableAssets(pageToken, pageNumber, filterName, filterType, filterVersionFirst, filterVersionLast, filterRepositoryUrl, filterRisksInProduction, filterRisksUnderAttack, filterRisksIsPubliclyAccessible, filterRisksHasPrivilegedAccess, filterRisksHasAccessToSensitiveData, filterEnvironments, filterArch, filterOperatingSystemName, filterOperatingSystemVersion, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'listVulnerableAssets'");
            if (!_config.unstableOperations["v2.listVulnerableAssets"]) {
                throw new Error("Unstable operation 'listVulnerableAssets' is disabled");
            }
            // Path Params
            const localVarPath = "/api/v2/security/assets";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.listVulnerableAssets")
                .makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageToken !== undefined) {
                requestContext.setQueryParam("page[token]", ObjectSerializer_1.ObjectSerializer.serialize(pageToken, "string", ""), "");
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"), "");
            }
            if (filterName !== undefined) {
                requestContext.setQueryParam("filter[name]", ObjectSerializer_1.ObjectSerializer.serialize(filterName, "string", ""), "");
            }
            if (filterType !== undefined) {
                requestContext.setQueryParam("filter[type]", ObjectSerializer_1.ObjectSerializer.serialize(filterType, "AssetType", ""), "");
            }
            if (filterVersionFirst !== undefined) {
                requestContext.setQueryParam("filter[version.first]", ObjectSerializer_1.ObjectSerializer.serialize(filterVersionFirst, "string", ""), "");
            }
            if (filterVersionLast !== undefined) {
                requestContext.setQueryParam("filter[version.last]", ObjectSerializer_1.ObjectSerializer.serialize(filterVersionLast, "string", ""), "");
            }
            if (filterRepositoryUrl !== undefined) {
                requestContext.setQueryParam("filter[repository_url]", ObjectSerializer_1.ObjectSerializer.serialize(filterRepositoryUrl, "string", ""), "");
            }
            if (filterRisksInProduction !== undefined) {
                requestContext.setQueryParam("filter[risks.in_production]", ObjectSerializer_1.ObjectSerializer.serialize(filterRisksInProduction, "boolean", ""), "");
            }
            if (filterRisksUnderAttack !== undefined) {
                requestContext.setQueryParam("filter[risks.under_attack]", ObjectSerializer_1.ObjectSerializer.serialize(filterRisksUnderAttack, "boolean", ""), "");
            }
            if (filterRisksIsPubliclyAccessible !== undefined) {
                requestContext.setQueryParam("filter[risks.is_publicly_accessible]", ObjectSerializer_1.ObjectSerializer.serialize(filterRisksIsPubliclyAccessible, "boolean", ""), "");
            }
            if (filterRisksHasPrivilegedAccess !== undefined) {
                requestContext.setQueryParam("filter[risks.has_privileged_access]", ObjectSerializer_1.ObjectSerializer.serialize(filterRisksHasPrivilegedAccess, "boolean", ""), "");
            }
            if (filterRisksHasAccessToSensitiveData !== undefined) {
                requestContext.setQueryParam("filter[risks.has_access_to_sensitive_data]", ObjectSerializer_1.ObjectSerializer.serialize(filterRisksHasAccessToSensitiveData, "boolean", ""), "");
            }
            if (filterEnvironments !== undefined) {
                requestContext.setQueryParam("filter[environments]", ObjectSerializer_1.ObjectSerializer.serialize(filterEnvironments, "string", ""), "");
            }
            if (filterArch !== undefined) {
                requestContext.setQueryParam("filter[arch]", ObjectSerializer_1.ObjectSerializer.serialize(filterArch, "string", ""), "");
            }
            if (filterOperatingSystemName !== undefined) {
                requestContext.setQueryParam("filter[operating_system.name]", ObjectSerializer_1.ObjectSerializer.serialize(filterOperatingSystemName, "string", ""), "");
            }
            if (filterOperatingSystemVersion !== undefined) {
                requestContext.setQueryParam("filter[operating_system.version]", ObjectSerializer_1.ObjectSerializer.serialize(filterOperatingSystemVersion, "string", ""), "");
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    muteFindings(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'muteFindings'");
            if (!_config.unstableOperations["v2.muteFindings"]) {
                throw new Error("Unstable operation 'muteFindings' is disabled");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "muteFindings");
            }
            // Path Params
            const localVarPath = "/api/v2/posture_management/findings";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.muteFindings")
                .makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "BulkMuteFindingsRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    patchSignalNotificationRule(id, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new baseapi_1.RequiredError("id", "patchSignalNotificationRule");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "patchSignalNotificationRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security/signals/notification_rules/{id}".replace("{id}", encodeURIComponent(String(id)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.patchSignalNotificationRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "PatchNotificationRuleParameters", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    patchVulnerabilityNotificationRule(id, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new baseapi_1.RequiredError("id", "patchVulnerabilityNotificationRule");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "patchVulnerabilityNotificationRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security/vulnerabilities/notification_rules/{id}".replace("{id}", encodeURIComponent(String(id)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.patchVulnerabilityNotificationRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "PatchNotificationRuleParameters", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    runHistoricalJob(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'runHistoricalJob'");
            if (!_config.unstableOperations["v2.runHistoricalJob"]) {
                throw new Error("Unstable operation 'runHistoricalJob' is disabled");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "runHistoricalJob");
            }
            // Path Params
            const localVarPath = "/api/v2/siem-historical-detections/jobs";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.runHistoricalJob")
                .makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RunHistoricalJobRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    searchSecurityMonitoringSignals(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/signals/search";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.searchSecurityMonitoringSignals")
                .makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringSignalListRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    testExistingSecurityMonitoringRule(ruleId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new baseapi_1.RequiredError("ruleId", "testExistingSecurityMonitoringRule");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "testExistingSecurityMonitoringRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules/{rule_id}/test".replace("{rule_id}", encodeURIComponent(String(ruleId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.testExistingSecurityMonitoringRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringRuleTestRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    testSecurityMonitoringRule(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "testSecurityMonitoringRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules/test";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.testSecurityMonitoringRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringRuleTestRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateSecurityFilter(securityFilterId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'securityFilterId' is not null or undefined
            if (securityFilterId === null || securityFilterId === undefined) {
                throw new baseapi_1.RequiredError("securityFilterId", "updateSecurityFilter");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateSecurityFilter");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/security_filters/{security_filter_id}".replace("{security_filter_id}", encodeURIComponent(String(securityFilterId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.updateSecurityFilter")
                .makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityFilterUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateSecurityMonitoringRule(ruleId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new baseapi_1.RequiredError("ruleId", "updateSecurityMonitoringRule");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateSecurityMonitoringRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules/{rule_id}".replace("{rule_id}", encodeURIComponent(String(ruleId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.updateSecurityMonitoringRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringRuleUpdatePayload", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateSecurityMonitoringSuppression(suppressionId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'suppressionId' is not null or undefined
            if (suppressionId === null || suppressionId === undefined) {
                throw new baseapi_1.RequiredError("suppressionId", "updateSecurityMonitoringSuppression");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateSecurityMonitoringSuppression");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/suppressions/{suppression_id}".replace("{suppression_id}", encodeURIComponent(String(suppressionId)));
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.updateSecurityMonitoringSuppression")
                .makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringSuppressionUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    validateSecurityMonitoringRule(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "validateSecurityMonitoringRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules/validation";
            // Make Request Context
            const requestContext = _config
                .getServer("v2.SecurityMonitoringApi.validateSecurityMonitoringRule")
                .makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringRuleValidatePayload", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.SecurityMonitoringApiRequestFactory = SecurityMonitoringApiRequestFactory;
class SecurityMonitoringApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to cancelHistoricalJob
     * @throws ApiException if the response code was not in [200, 299]
     */
    cancelHistoricalJob(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 204) {
                return;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 401 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 409 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to convertExistingSecurityMonitoringRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    convertExistingSecurityMonitoringRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleConvertResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleConvertResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to convertJobResultToSignal
     * @throws ApiException if the response code was not in [200, 299]
     */
    convertJobResultToSignal(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 204) {
                return;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 401 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to convertSecurityMonitoringRuleFromJSONToTerraform
     * @throws ApiException if the response code was not in [200, 299]
     */
    convertSecurityMonitoringRuleFromJSONToTerraform(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleConvertResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 401 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleConvertResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createSecurityFilter
     * @throws ApiException if the response code was not in [200, 299]
     */
    createSecurityFilter(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFilterResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 409 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFilterResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createSecurityMonitoringRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    createSecurityMonitoringRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createSecurityMonitoringSuppression
     * @throws ApiException if the response code was not in [200, 299]
     */
    createSecurityMonitoringSuppression(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSuppressionResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 409 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSuppressionResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createSignalNotificationRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    createSignalNotificationRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotificationRuleResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotificationRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createVulnerabilityNotificationRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    createVulnerabilityNotificationRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotificationRuleResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotificationRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteHistoricalJob
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteHistoricalJob(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 204) {
                return;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 401 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 409 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteSecurityFilter
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteSecurityFilter(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 204) {
                return;
            }
            if (response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteSecurityMonitoringRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteSecurityMonitoringRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 204) {
                return;
            }
            if (response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteSecurityMonitoringSuppression
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteSecurityMonitoringSuppression(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 204) {
                return;
            }
            if (response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteSignalNotificationRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteSignalNotificationRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 204) {
                return;
            }
            if (response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteVulnerabilityNotificationRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteVulnerabilityNotificationRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 204) {
                return;
            }
            if (response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to editSecurityMonitoringSignalAssignee
     * @throws ApiException if the response code was not in [200, 299]
     */
    editSecurityMonitoringSignalAssignee(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalTriageUpdateResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalTriageUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to editSecurityMonitoringSignalIncidents
     * @throws ApiException if the response code was not in [200, 299]
     */
    editSecurityMonitoringSignalIncidents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalTriageUpdateResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalTriageUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to editSecurityMonitoringSignalState
     * @throws ApiException if the response code was not in [200, 299]
     */
    editSecurityMonitoringSignalState(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalTriageUpdateResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalTriageUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getFinding
     * @throws ApiException if the response code was not in [200, 299]
     */
    getFinding(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "GetFindingResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "JSONAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "GetFindingResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getHistoricalJob
     * @throws ApiException if the response code was not in [200, 299]
     */
    getHistoricalJob(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HistoricalJobResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HistoricalJobResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getRuleVersionHistory
     * @throws ApiException if the response code was not in [200, 299]
     */
    getRuleVersionHistory(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "GetRuleVersionHistoryResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "GetRuleVersionHistoryResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSBOM
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSBOM(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "GetSBOMResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "JSONAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "GetSBOMResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSecurityFilter
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSecurityFilter(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFilterResponse");
                return body;
            }
            if (response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFilterResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSecurityMonitoringRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSecurityMonitoringRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleResponse");
                return body;
            }
            if (response.httpStatusCode === 404 || response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSecurityMonitoringSignal
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSecurityMonitoringSignal(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalResponse");
                return body;
            }
            if (response.httpStatusCode === 404 || response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSecurityMonitoringSuppression
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSecurityMonitoringSuppression(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSuppressionResponse");
                return body;
            }
            if (response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSuppressionResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSignalNotificationRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSignalNotificationRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotificationRuleResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotificationRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSignalNotificationRules
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSignalNotificationRules(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode === 403 || response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getVulnerabilityNotificationRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    getVulnerabilityNotificationRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotificationRuleResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotificationRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getVulnerabilityNotificationRules
     * @throws ApiException if the response code was not in [200, 299]
     */
    getVulnerabilityNotificationRules(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode === 403 || response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listFindings
     * @throws ApiException if the response code was not in [200, 299]
     */
    listFindings(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListFindingsResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "JSONAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListFindingsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listHistoricalJobs
     * @throws ApiException if the response code was not in [200, 299]
     */
    listHistoricalJobs(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListHistoricalJobsResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListHistoricalJobsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listSecurityFilters
     * @throws ApiException if the response code was not in [200, 299]
     */
    listSecurityFilters(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFiltersResponse");
                return body;
            }
            if (response.httpStatusCode === 403 || response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFiltersResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listSecurityMonitoringRules
     * @throws ApiException if the response code was not in [200, 299]
     */
    listSecurityMonitoringRules(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringListRulesResponse");
                return body;
            }
            if (response.httpStatusCode === 400 || response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringListRulesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listSecurityMonitoringSignals
     * @throws ApiException if the response code was not in [200, 299]
     */
    listSecurityMonitoringSignals(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalsListResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalsListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listSecurityMonitoringSuppressions
     * @throws ApiException if the response code was not in [200, 299]
     */
    listSecurityMonitoringSuppressions(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSuppressionsResponse");
                return body;
            }
            if (response.httpStatusCode === 403 || response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSuppressionsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVulnerabilities
     * @throws ApiException if the response code was not in [200, 299]
     */
    listVulnerabilities(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListVulnerabilitiesResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "JSONAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListVulnerabilitiesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVulnerableAssets
     * @throws ApiException if the response code was not in [200, 299]
     */
    listVulnerableAssets(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListVulnerableAssetsResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "JSONAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListVulnerableAssetsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to muteFindings
     * @throws ApiException if the response code was not in [200, 299]
     */
    muteFindings(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "BulkMuteFindingsResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 422 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "JSONAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "BulkMuteFindingsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchSignalNotificationRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    patchSignalNotificationRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotificationRuleResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode === 422) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "JSONAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotificationRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchVulnerabilityNotificationRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    patchVulnerabilityNotificationRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotificationRuleResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode === 422) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "JSONAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotificationRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to runHistoricalJob
     * @throws ApiException if the response code was not in [200, 299]
     */
    runHistoricalJob(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "JobCreateResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 401 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "JobCreateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to searchSecurityMonitoringSignals
     * @throws ApiException if the response code was not in [200, 299]
     */
    searchSecurityMonitoringSignals(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalsListResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalsListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to testExistingSecurityMonitoringRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    testExistingSecurityMonitoringRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleTestResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 401 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleTestResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to testSecurityMonitoringRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    testSecurityMonitoringRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleTestResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 401 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleTestResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateSecurityFilter
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateSecurityFilter(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFilterResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 409 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFilterResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateSecurityMonitoringRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateSecurityMonitoringRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 401 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateSecurityMonitoringSuppression
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateSecurityMonitoringSuppression(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSuppressionResponse");
                return body;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 404 ||
                response.httpStatusCode === 409 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSuppressionResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to validateSecurityMonitoringRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    validateSecurityMonitoringRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode === 204) {
                return;
            }
            if (response.httpStatusCode === 400 ||
                response.httpStatusCode === 403 ||
                response.httpStatusCode === 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.debug(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.SecurityMonitoringApiResponseProcessor = SecurityMonitoringApiResponseProcessor;
class SecurityMonitoringApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new SecurityMonitoringApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new SecurityMonitoringApiResponseProcessor();
    }
    /**
     * Cancel a historical job.
     * @param param The request object
     */
    cancelHistoricalJob(param, options) {
        const requestContextPromise = this.requestFactory.cancelHistoricalJob(param.jobId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.cancelHistoricalJob(responseContext);
            });
        });
    }
    /**
     * Convert an existing rule from JSON to Terraform for datadog provider
     * resource datadog_security_monitoring_rule.
     * @param param The request object
     */
    convertExistingSecurityMonitoringRule(param, options) {
        const requestContextPromise = this.requestFactory.convertExistingSecurityMonitoringRule(param.ruleId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.convertExistingSecurityMonitoringRule(responseContext);
            });
        });
    }
    /**
     * Convert a job result to a signal.
     * @param param The request object
     */
    convertJobResultToSignal(param, options) {
        const requestContextPromise = this.requestFactory.convertJobResultToSignal(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.convertJobResultToSignal(responseContext);
            });
        });
    }
    /**
     * Convert a rule that doesn't (yet) exist from JSON to Terraform for datadog provider
     * resource datadog_security_monitoring_rule.
     * @param param The request object
     */
    convertSecurityMonitoringRuleFromJSONToTerraform(param, options) {
        const requestContextPromise = this.requestFactory.convertSecurityMonitoringRuleFromJSONToTerraform(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.convertSecurityMonitoringRuleFromJSONToTerraform(responseContext);
            });
        });
    }
    /**
     * Create a security filter.
     *
     * See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
     * for more examples.
     * @param param The request object
     */
    createSecurityFilter(param, options) {
        const requestContextPromise = this.requestFactory.createSecurityFilter(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createSecurityFilter(responseContext);
            });
        });
    }
    /**
     * Create a detection rule.
     * @param param The request object
     */
    createSecurityMonitoringRule(param, options) {
        const requestContextPromise = this.requestFactory.createSecurityMonitoringRule(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createSecurityMonitoringRule(responseContext);
            });
        });
    }
    /**
     * Create a new suppression rule.
     * @param param The request object
     */
    createSecurityMonitoringSuppression(param, options) {
        const requestContextPromise = this.requestFactory.createSecurityMonitoringSuppression(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createSecurityMonitoringSuppression(responseContext);
            });
        });
    }
    /**
     * Create a new notification rule for security signals and return the created rule.
     * @param param The request object
     */
    createSignalNotificationRule(param, options) {
        const requestContextPromise = this.requestFactory.createSignalNotificationRule(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createSignalNotificationRule(responseContext);
            });
        });
    }
    /**
     * Create a new notification rule for security vulnerabilities and return the created rule.
     * @param param The request object
     */
    createVulnerabilityNotificationRule(param, options) {
        const requestContextPromise = this.requestFactory.createVulnerabilityNotificationRule(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createVulnerabilityNotificationRule(responseContext);
            });
        });
    }
    /**
     * Delete an existing job.
     * @param param The request object
     */
    deleteHistoricalJob(param, options) {
        const requestContextPromise = this.requestFactory.deleteHistoricalJob(param.jobId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteHistoricalJob(responseContext);
            });
        });
    }
    /**
     * Delete a specific security filter.
     * @param param The request object
     */
    deleteSecurityFilter(param, options) {
        const requestContextPromise = this.requestFactory.deleteSecurityFilter(param.securityFilterId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteSecurityFilter(responseContext);
            });
        });
    }
    /**
     * Delete an existing rule. Default rules cannot be deleted.
     * @param param The request object
     */
    deleteSecurityMonitoringRule(param, options) {
        const requestContextPromise = this.requestFactory.deleteSecurityMonitoringRule(param.ruleId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteSecurityMonitoringRule(responseContext);
            });
        });
    }
    /**
     * Delete a specific suppression rule.
     * @param param The request object
     */
    deleteSecurityMonitoringSuppression(param, options) {
        const requestContextPromise = this.requestFactory.deleteSecurityMonitoringSuppression(param.suppressionId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteSecurityMonitoringSuppression(responseContext);
            });
        });
    }
    /**
     * Delete a notification rule for security signals.
     * @param param The request object
     */
    deleteSignalNotificationRule(param, options) {
        const requestContextPromise = this.requestFactory.deleteSignalNotificationRule(param.id, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteSignalNotificationRule(responseContext);
            });
        });
    }
    /**
     * Delete a notification rule for security vulnerabilities.
     * @param param The request object
     */
    deleteVulnerabilityNotificationRule(param, options) {
        const requestContextPromise = this.requestFactory.deleteVulnerabilityNotificationRule(param.id, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteVulnerabilityNotificationRule(responseContext);
            });
        });
    }
    /**
     * Modify the triage assignee of a security signal.
     * @param param The request object
     */
    editSecurityMonitoringSignalAssignee(param, options) {
        const requestContextPromise = this.requestFactory.editSecurityMonitoringSignalAssignee(param.signalId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.editSecurityMonitoringSignalAssignee(responseContext);
            });
        });
    }
    /**
     * Change the related incidents for a security signal.
     * @param param The request object
     */
    editSecurityMonitoringSignalIncidents(param, options) {
        const requestContextPromise = this.requestFactory.editSecurityMonitoringSignalIncidents(param.signalId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.editSecurityMonitoringSignalIncidents(responseContext);
            });
        });
    }
    /**
     * Change the triage state of a security signal.
     * @param param The request object
     */
    editSecurityMonitoringSignalState(param, options) {
        const requestContextPromise = this.requestFactory.editSecurityMonitoringSignalState(param.signalId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.editSecurityMonitoringSignalState(responseContext);
            });
        });
    }
    /**
     * Returns a single finding with message and resource configuration.
     * @param param The request object
     */
    getFinding(param, options) {
        const requestContextPromise = this.requestFactory.getFinding(param.findingId, param.snapshotTimestamp, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getFinding(responseContext);
            });
        });
    }
    /**
     * Get a job's details.
     * @param param The request object
     */
    getHistoricalJob(param, options) {
        const requestContextPromise = this.requestFactory.getHistoricalJob(param.jobId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getHistoricalJob(responseContext);
            });
        });
    }
    /**
     * Get a rule's version history.
     * @param param The request object
     */
    getRuleVersionHistory(param, options) {
        const requestContextPromise = this.requestFactory.getRuleVersionHistory(param.ruleId, param.pageSize, param.pageNumber, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getRuleVersionHistory(responseContext);
            });
        });
    }
    /**
     * Get a single SBOM related to an asset by its type and name.
     * @param param The request object
     */
    getSBOM(param, options) {
        const requestContextPromise = this.requestFactory.getSBOM(param.assetType, param.filterAssetName, param.filterRepoDigest, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSBOM(responseContext);
            });
        });
    }
    /**
     * Get the details of a specific security filter.
     *
     * See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
     * for more examples.
     * @param param The request object
     */
    getSecurityFilter(param, options) {
        const requestContextPromise = this.requestFactory.getSecurityFilter(param.securityFilterId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSecurityFilter(responseContext);
            });
        });
    }
    /**
     * Get a rule's details.
     * @param param The request object
     */
    getSecurityMonitoringRule(param, options) {
        const requestContextPromise = this.requestFactory.getSecurityMonitoringRule(param.ruleId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSecurityMonitoringRule(responseContext);
            });
        });
    }
    /**
     * Get a signal's details.
     * @param param The request object
     */
    getSecurityMonitoringSignal(param, options) {
        const requestContextPromise = this.requestFactory.getSecurityMonitoringSignal(param.signalId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSecurityMonitoringSignal(responseContext);
            });
        });
    }
    /**
     * Get the details of a specific suppression rule.
     * @param param The request object
     */
    getSecurityMonitoringSuppression(param, options) {
        const requestContextPromise = this.requestFactory.getSecurityMonitoringSuppression(param.suppressionId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSecurityMonitoringSuppression(responseContext);
            });
        });
    }
    /**
     * Get the details of a notification rule for security signals.
     * @param param The request object
     */
    getSignalNotificationRule(param, options) {
        const requestContextPromise = this.requestFactory.getSignalNotificationRule(param.id, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSignalNotificationRule(responseContext);
            });
        });
    }
    /**
     * Returns the list of notification rules for security signals.
     * @param param The request object
     */
    getSignalNotificationRules(options) {
        const requestContextPromise = this.requestFactory.getSignalNotificationRules(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSignalNotificationRules(responseContext);
            });
        });
    }
    /**
     * Get the details of a notification rule for security vulnerabilities.
     * @param param The request object
     */
    getVulnerabilityNotificationRule(param, options) {
        const requestContextPromise = this.requestFactory.getVulnerabilityNotificationRule(param.id, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getVulnerabilityNotificationRule(responseContext);
            });
        });
    }
    /**
     * Returns the list of notification rules for security vulnerabilities.
     * @param param The request object
     */
    getVulnerabilityNotificationRules(options) {
        const requestContextPromise = this.requestFactory.getVulnerabilityNotificationRules(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getVulnerabilityNotificationRules(responseContext);
            });
        });
    }
    /**
     * Get a list of findings. These include both misconfigurations and identity risks.
     *
     * **Note**: To filter and return only identity risks, add the following query parameter: `?filter[tags]=dd_rule_type:ciem`
     *
     * ### Filtering
     *
     * Filters can be applied by appending query parameters to the URL.
     *
     *   - Using a single filter: `?filter[attribute_key]=attribute_value`
     *   - Chaining filters: `?filter[attribute_key]=attribute_value&filter[attribute_key]=attribute_value...`
     *   - Filtering on tags: `?filter[tags]=tag_key:tag_value&filter[tags]=tag_key_2:tag_value_2`
     *
     * Here, `attribute_key` can be any of the filter keys described further below.
     *
     * Query parameters of type `integer` support comparison operators (`>`, `>=`, `<`, `<=`). This is particularly useful when filtering by `evaluation_changed_at` or `resource_discovery_timestamp`. For example: `?filter[evaluation_changed_at]=>20123123121`.
     *
     * You can also use the negation operator on strings. For example, use `filter[resource_type]=-aws*` to filter for any non-AWS resources.
     *
     * The operator must come after the equal sign. For example, to filter with the `>=` operator, add the operator after the equal sign: `filter[evaluation_changed_at]=>=1678809373257`.
     *
     * Query parameters must be only among the documented ones and with values of correct types. Duplicated query parameters (e.g. `filter[status]=low&filter[status]=info`) are not allowed.
     *
     * ### Response
     *
     * The response includes an array of finding objects, pagination metadata, and a count of items that match the query.
     *
     * Each finding object contains the following:
     *
     * - The finding ID that can be used in a `GetFinding` request to retrieve the full finding details.
     * - Core attributes, including status, evaluation, high-level resource details, muted state, and rule details.
     * - `evaluation_changed_at` and `resource_discovery_date` time stamps.
     * - An array of associated tags.
     * @param param The request object
     */
    listFindings(param = {}, options) {
        const requestContextPromise = this.requestFactory.listFindings(param.pageLimit, param.snapshotTimestamp, param.pageCursor, param.filterTags, param.filterEvaluationChangedAt, param.filterMuted, param.filterRuleId, param.filterRuleName, param.filterResourceType, param.filterDiscoveryTimestamp, param.filterEvaluation, param.filterStatus, param.filterVulnerabilityType, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listFindings(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of listFindings returning a generator with all the items.
     */
    listFindingsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* listFindingsWithPagination_1() {
            let pageSize = 100;
            if (param.pageLimit !== undefined) {
                pageSize = param.pageLimit;
            }
            param.pageLimit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.listFindings(param.pageLimit, param.snapshotTimestamp, param.pageCursor, param.filterTags, param.filterEvaluationChangedAt, param.filterMuted, param.filterRuleId, param.filterRuleName, param.filterResourceType, param.filterDiscoveryTimestamp, param.filterEvaluation, param.filterStatus, param.filterVulnerabilityType, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.listFindings(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageCursor = cursorMetaPage.cursor;
                if (cursorMetaPageCursor === undefined) {
                    break;
                }
                param.pageCursor = cursorMetaPageCursor;
            }
        });
    }
    /**
     * List historical jobs.
     * @param param The request object
     */
    listHistoricalJobs(param = {}, options) {
        const requestContextPromise = this.requestFactory.listHistoricalJobs(param.pageSize, param.pageNumber, param.sort, param.filterQuery, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listHistoricalJobs(responseContext);
            });
        });
    }
    /**
     * Get the list of configured security filters with their definitions.
     * @param param The request object
     */
    listSecurityFilters(options) {
        const requestContextPromise = this.requestFactory.listSecurityFilters(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listSecurityFilters(responseContext);
            });
        });
    }
    /**
     * List rules.
     * @param param The request object
     */
    listSecurityMonitoringRules(param = {}, options) {
        const requestContextPromise = this.requestFactory.listSecurityMonitoringRules(param.pageSize, param.pageNumber, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listSecurityMonitoringRules(responseContext);
            });
        });
    }
    /**
     * The list endpoint returns security signals that match a search query.
     * Both this endpoint and the POST endpoint can be used interchangeably when listing
     * security signals.
     * @param param The request object
     */
    listSecurityMonitoringSignals(param = {}, options) {
        const requestContextPromise = this.requestFactory.listSecurityMonitoringSignals(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listSecurityMonitoringSignals(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of listSecurityMonitoringSignals returning a generator with all the items.
     */
    listSecurityMonitoringSignalsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* listSecurityMonitoringSignalsWithPagination_1() {
            let pageSize = 10;
            if (param.pageLimit !== undefined) {
                pageSize = param.pageLimit;
            }
            param.pageLimit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.listSecurityMonitoringSignals(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.listSecurityMonitoringSignals(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.pageCursor = cursorMetaPageAfter;
            }
        });
    }
    /**
     * Get the list of all suppression rules.
     * @param param The request object
     */
    listSecurityMonitoringSuppressions(options) {
        const requestContextPromise = this.requestFactory.listSecurityMonitoringSuppressions(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listSecurityMonitoringSuppressions(responseContext);
            });
        });
    }
    /**
     * Get a list of vulnerabilities.
     *
     * ### Pagination
     *
     * Pagination is enabled by default in both `vulnerabilities` and `assets`. The size of the page varies depending on the endpoint and cannot be modified. To automate the request of the next page, you can use the links section in the response.
     *
     * This endpoint will return paginated responses. The pages are stored in the links section of the response:
     *
     * ```JSON
     * {
     *   "data": [...],
     *   "meta": {...},
     *   "links": {
     *     "self": "https://.../api/v2/security/vulnerabilities",
     *     "first": "https://.../api/v2/security/vulnerabilities?page[number]=1&page[token]=abc",
     *     "last": "https://.../api/v2/security/vulnerabilities?page[number]=43&page[token]=abc",
     *     "next": "https://.../api/v2/security/vulnerabilities?page[number]=2&page[token]=abc"
     *   }
     * }
     * ```
     *
     *
     * - `links.previous` is empty if the first page is requested.
     * - `links.next` is empty if the last page is requested.
     *
     * #### Token
     *
     * Vulnerabilities can be created, updated or deleted at any point in time.
     *
     * Upon the first request, a token is created to ensure consistency across subsequent paginated requests.
     *
     * A token is valid only for 24 hours.
     *
     * #### First request
     *
     * We consider a request to be the first request when there is no `page[token]` parameter.
     *
     * The response of this first request contains the newly created token in the `links` section.
     *
     * This token can then be used in the subsequent paginated requests.
     *
     * #### Subsequent requests
     *
     * Any request containing valid `page[token]` and `page[number]` parameters will be considered a subsequent request.
     *
     * If the `token` is invalid, a `404` response will be returned.
     *
     * If the page `number` is invalid, a `400` response will be returned.
     *
     * ### Filtering
     *
     * The request can include some filter parameters to filter the data to be retrieved. The format of the filter parameters follows the [JSON:API format](https://jsonapi.org/format/#fetching-filtering): `filter[$prop_name]`, where `prop_name` is the property name in the entity being filtered by.
     *
     * All filters can include multiple values, where data will be filtered with an OR clause: `filter[title]=Title1,Title2` will filter all vulnerabilities where title is equal to `Title1` OR `Title2`.
     *
     * String filters are case sensitive.
     *
     * Boolean filters accept `true` or `false` as values.
     *
     * Number filters must include an operator as a second filter input: `filter[$prop_name][$operator]`. For example, for the vulnerabilities endpoint: `filter[cvss.base.score][lte]=8`.
     *
     * Available operators are: `eq` (==), `lt` (<), `lte` (<=), `gt` (>) and `gte` (>=).
     *
     * ### Metadata
     *
     * Following [JSON:API format](https://jsonapi.org/format/#document-meta), object including non-standard meta-information.
     *
     * This endpoint includes the meta member in the response. For more details on each of the properties included in this section, check the endpoints response tables.
     *
     * ```JSON
     * {
     *   "data": [...],
     *   "meta": {
     *     "total": 1500,
     *     "count": 18732,
     *     "token": "some_token"
     *   },
     *   "links": {...}
     * }
     * ```
     * @param param The request object
     */
    listVulnerabilities(param = {}, options) {
        const requestContextPromise = this.requestFactory.listVulnerabilities(param.pageToken, param.pageNumber, param.filterType, param.filterCvssBaseScoreOp, param.filterCvssBaseSeverity, param.filterCvssBaseVector, param.filterCvssDatadogScoreOp, param.filterCvssDatadogSeverity, param.filterCvssDatadogVector, param.filterStatus, param.filterTool, param.filterLibraryName, param.filterLibraryVersion, param.filterAdvisoryId, param.filterRisksExploitationProbability, param.filterRisksPocExploitAvailable, param.filterRisksExploitAvailable, param.filterRisksEpssScoreOp, param.filterRisksEpssSeverity, param.filterLanguage, param.filterEcosystem, param.filterCodeLocationLocation, param.filterCodeLocationFilePath, param.filterCodeLocationMethod, param.filterFixAvailable, param.filterRepoDigests, param.filterAssetName, param.filterAssetType, param.filterAssetVersionFirst, param.filterAssetVersionLast, param.filterAssetRepositoryUrl, param.filterAssetRisksInProduction, param.filterAssetRisksUnderAttack, param.filterAssetRisksIsPubliclyAccessible, param.filterAssetRisksHasPrivilegedAccess, param.filterAssetRisksHasAccessToSensitiveData, param.filterAssetEnvironments, param.filterAssetArch, param.filterAssetOperatingSystemName, param.filterAssetOperatingSystemVersion, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listVulnerabilities(responseContext);
            });
        });
    }
    /**
     * Get a list of vulnerable assets.
     *
     * ### Pagination
     *
     * Please review the [Pagination section for the "List Vulnerabilities"](#pagination) endpoint.
     *
     * ### Filtering
     *
     * Please review the [Filtering section for the "List Vulnerabilities"](#filtering) endpoint.
     *
     * ### Metadata
     *
     * Please review the [Metadata section for the "List Vulnerabilities"](#metadata) endpoint.
     * @param param The request object
     */
    listVulnerableAssets(param = {}, options) {
        const requestContextPromise = this.requestFactory.listVulnerableAssets(param.pageToken, param.pageNumber, param.filterName, param.filterType, param.filterVersionFirst, param.filterVersionLast, param.filterRepositoryUrl, param.filterRisksInProduction, param.filterRisksUnderAttack, param.filterRisksIsPubliclyAccessible, param.filterRisksHasPrivilegedAccess, param.filterRisksHasAccessToSensitiveData, param.filterEnvironments, param.filterArch, param.filterOperatingSystemName, param.filterOperatingSystemVersion, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listVulnerableAssets(responseContext);
            });
        });
    }
    /**
     * Mute or unmute findings.
     * @param param The request object
     */
    muteFindings(param, options) {
        const requestContextPromise = this.requestFactory.muteFindings(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.muteFindings(responseContext);
            });
        });
    }
    /**
     * Partially update the notification rule. All fields are optional; if a field is not provided, it is not updated.
     * @param param The request object
     */
    patchSignalNotificationRule(param, options) {
        const requestContextPromise = this.requestFactory.patchSignalNotificationRule(param.id, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.patchSignalNotificationRule(responseContext);
            });
        });
    }
    /**
     * Partially update the notification rule. All fields are optional; if a field is not provided, it is not updated.
     * @param param The request object
     */
    patchVulnerabilityNotificationRule(param, options) {
        const requestContextPromise = this.requestFactory.patchVulnerabilityNotificationRule(param.id, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.patchVulnerabilityNotificationRule(responseContext);
            });
        });
    }
    /**
     * Run a historical job.
     * @param param The request object
     */
    runHistoricalJob(param, options) {
        const requestContextPromise = this.requestFactory.runHistoricalJob(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.runHistoricalJob(responseContext);
            });
        });
    }
    /**
     * Returns security signals that match a search query.
     * Both this endpoint and the GET endpoint can be used interchangeably for listing
     * security signals.
     * @param param The request object
     */
    searchSecurityMonitoringSignals(param = {}, options) {
        const requestContextPromise = this.requestFactory.searchSecurityMonitoringSignals(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.searchSecurityMonitoringSignals(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of searchSecurityMonitoringSignals returning a generator with all the items.
     */
    searchSecurityMonitoringSignalsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* searchSecurityMonitoringSignalsWithPagination_1() {
            let pageSize = 10;
            if (param.body === undefined) {
                param.body = new SecurityMonitoringSignalListRequest_1.SecurityMonitoringSignalListRequest();
            }
            if (param.body.page === undefined) {
                param.body.page = new SecurityMonitoringSignalListRequestPage_1.SecurityMonitoringSignalListRequestPage();
            }
            if (param.body.page.limit !== undefined) {
                pageSize = param.body.page.limit;
            }
            param.body.page.limit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.searchSecurityMonitoringSignals(param.body, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.searchSecurityMonitoringSignals(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.body.page.cursor = cursorMetaPageAfter;
            }
        });
    }
    /**
     * Test an existing rule.
     * @param param The request object
     */
    testExistingSecurityMonitoringRule(param, options) {
        const requestContextPromise = this.requestFactory.testExistingSecurityMonitoringRule(param.ruleId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.testExistingSecurityMonitoringRule(responseContext);
            });
        });
    }
    /**
     * Test a rule.
     * @param param The request object
     */
    testSecurityMonitoringRule(param, options) {
        const requestContextPromise = this.requestFactory.testSecurityMonitoringRule(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.testSecurityMonitoringRule(responseContext);
            });
        });
    }
    /**
     * Update a specific security filter.
     * Returns the security filter object when the request is successful.
     * @param param The request object
     */
    updateSecurityFilter(param, options) {
        const requestContextPromise = this.requestFactory.updateSecurityFilter(param.securityFilterId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateSecurityFilter(responseContext);
            });
        });
    }
    /**
     * Update an existing rule. When updating `cases`, `queries` or `options`, the whole field
     * must be included. For example, when modifying a query all queries must be included.
     * Default rules can only be updated to be enabled, to change notifications, or to update
     * the tags (default tags cannot be removed).
     * @param param The request object
     */
    updateSecurityMonitoringRule(param, options) {
        const requestContextPromise = this.requestFactory.updateSecurityMonitoringRule(param.ruleId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateSecurityMonitoringRule(responseContext);
            });
        });
    }
    /**
     * Update a specific suppression rule.
     * @param param The request object
     */
    updateSecurityMonitoringSuppression(param, options) {
        const requestContextPromise = this.requestFactory.updateSecurityMonitoringSuppression(param.suppressionId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateSecurityMonitoringSuppression(responseContext);
            });
        });
    }
    /**
     * Validate a detection rule.
     * @param param The request object
     */
    validateSecurityMonitoringRule(param, options) {
        const requestContextPromise = this.requestFactory.validateSecurityMonitoringRule(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.validateSecurityMonitoringRule(responseContext);
            });
        });
    }
}
exports.SecurityMonitoringApi = SecurityMonitoringApi;
//# sourceMappingURL=SecurityMonitoringApi.js.map